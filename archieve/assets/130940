현재 노드에 방문을 하지 않은 상태에서, 다음 정점으로 가는 노드가 추가되는 것이 누적되어서 그렇습니다.
그리고 그래프의 연결 방법에 따라 현재 노드는 영원이 방문 되지 않을 수 있습니다.

이런 실수는 특히 bfs나 dfs 할 때 자주하는 실수 중 하나 입니다. 
dfs랑 bfs는 이후에도 많이 응용되는데, 이 부분을 확실히 하지 않으면 나중에 고생합니다. 저 처럼요

작성하신 코드를 패턴적으로 한 번 보겠습니다.
표현이 다소 단순화돼있거나, 약간의 변형이 있습니다.

0. 시작 정점을 Q에 입력
1. 현재 노드 pop(left)
2. 현재 노드 방문 처리
3. 다음 노드가 탈출 조건 1이면, 탈출
    - 탈출 조건 1은, 다음 노드의 좌표가 맵 경계 바깥을 가르키는지 확인합니다.
    - 여기서 `탈출`은if문 바깥에 아무것도 없는 것으로 구현하셨습니다.
4. 다음 노드가 탈출 조건 2이면, 탈출
    - 지도의 다음 노드 좌표에 해당하는 곳에 0이 있으면 갈 수 없습니다. 이는 문제의 조건에 따라 탈출 조건이 됩니다.
    - 여기서의 `탈출`은 continue로 구현하셨습니다.
5. 다음 노드가 방문 처리가 되지 않았다면, 탈출
    - 여기서의 `탈출`은(el)if문 바깥에 아무것도 없는 것으로 구현하셨습니다.
6. 다음 노드의 방문 처리
    - 주석을 처리하셨으니 이 문은 실행되지 않습니다.
7. 다음 노드 추가
- Q가 빌 때까지 1 ~ 7을 반복

처음에 현재 노드가 방문 되지 않은 채로 다음 정점이 여러 번 추가될 수 있다고 했습니다.
이러한 방문 처리를 제대로 하지 않았을 때 무한 루프가 발생합니다.
 이미 방문한 정점을 여러 번 확인하게되니까요. 

꼭 무한 루프가 아니더라도 이미 방문한 정점을 불필요하게 방문하게 됨에 따라 
(예상보다 작은 그래프인데도)시간 초과, (Q의 크기가 과하게 커지므로)메모리 초과 등 온갖 문제가 다 발생할 수 있습니다.

그런 문제가 있을 수도 있는 것을 확인하기 좋은 가장 쉬운 문제가 바로 이 문제입니다.
인접한 상하좌우로 이동 가능하니, 불필요한 방문도 여러 번 할 수 있게 됩니다.

모든 방문 처리를 요구하는, 그래프 순회 과정에서 일어날 수 있는 내용에 대해서 설명드렸습니다.
앞으로는 이런 문제가 더 발생하지 않도록 조심하셔야겠네요.

마지막으로, 제가 이런 유형에서 쓰는 레시피에 주석 달아서 공유해드립니다. 단, dfs 템플릿임에 주의하세요.
저의 또 다른 템플릿은  https://github.com/kimdw9983/a... 에서 algorithm 폴더를 확인하실 수 있습니다. 계속 업데이트하고 있습니다.